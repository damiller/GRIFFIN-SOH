/********************************************************************\

  Name:         mscbMakeCode.cxx
  Created by:   K.Olchanski

  Contents:     Probe an MSCB device and generate driver code for it.

  $Id$

\********************************************************************/

#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <string>
#include <sys/time.h>
#include <assert.h>

#include "midas.h"
#include "mscb.h"

int MakeMscbCode(int mscb, int addr)
{
  int status;
  MSCB_INFO node_info;
  status = mscb_info(mscb, addr, &node_info);

  fprintf(stderr, "MSCB device at address %d, name \"%s\", svn_revision %d, found %d variables:\n", addr, node_info.node_name, node_info.svn_revision, node_info.n_variables);

  char devname[1000];
  sprintf(devname, "%s_%d", node_info.node_name, node_info.svn_revision);

  char fname[256];
  sprintf(fname, "mscb_%s.h", devname);

  FILE *fp = fopen(fname,"w");
  if (!fp) {
    fprintf(stderr, "Cannot open output file %s, errno %d (%s)\n", fname, errno, strerror(errno));
    return -1;
  }

  fprintf(stderr, "Writing MSCB device description to %s...\n", fname);

  fprintf(fp, "/* This file is generated by mscbMakeCode.exe */\n");
  fprintf(fp, "\n");
  fprintf(fp, "#ifndef MSCB_%s_h\n", devname);
  fprintf(fp, "#define MSCB_%s_h\n", devname);
  fprintf(fp, "\n");

  std::string bank_def;
  std::string bank_copy;
  std::string defines;

  if (1)
    {
      char str[256];
      sprintf(str,"#define %s_%-15s \"%s\"\n", devname, "NODE_NAME", node_info.node_name);
      defines += str;
    }

  if (1)
    {
      char str[256];
      sprintf(str,"#define %s_%-15s %3d\n", devname, "SVN_REVISION", node_info.svn_revision);
      defines += str;
    }

  if (1)
    {
      char str[256];
      sprintf(str,"#define %s_%-15s %3d\n", devname, "NUM_VARS", node_info.n_variables);
      defines += str;
    }

  fprintf(fp, "\n");

  fprintf(fp, "struct %s_bank {\n", devname);

  int boffset = 0;

  int bcount = 0;

  if (1)
    {
      char str[256];

      boffset += 4;
      fprintf(fp, "   uint32_t _timestamp;\n");
      sprintf(str, "   \"%-10s = DWORD\",\n", "_timestamp");
      bank_def += str;

      boffset += 1;
      fprintf(fp, "   uint8_t  _protocol_version;\n");
      sprintf(str, "   \"%-10s = BYTE\",\n", "_protocol_version");
      bank_def += str;

      boffset += 1;
      fprintf(fp, "   uint8_t  _n_variables;\n");
      sprintf(str, "   \"%-10s = BYTE\",\n", "_n_variables");
      bank_def += str;

      boffset += 2;
      fprintf(fp, "   uint16_t _node_address;\n");
      sprintf(str, "   \"%-10s = WORD\",\n", "_node_address");
      bank_def += str;

      boffset += 2;
      fprintf(fp, "   uint16_t _group_address;\n");
      sprintf(str, "   \"%-10s = WORD\",\n", "_group_address");
      bank_def += str;

      boffset += 2;
      fprintf(fp, "   uint16_t _svn_revision;\n");
      sprintf(str, "   \"%-10s = WORD\",\n", "_svn_revision");
      bank_def += str;
    }

  char xvarname[1000][256];

  int ipad = 1;
  for (int i=0; i<node_info.n_variables; i++)
    {
      MSCB_INFO_VAR var_info;
      status =  mscb_info_variable(mscb, addr, i, &var_info);

      char name[9];
      memset(name, 0, sizeof(name));
      memcpy(name, var_info.name, 8);

      char varname[256];
      memset(varname, 0, sizeof(varname));

      for (int j=0; j<9; j++)
	{
	  if (name[j]==0)
	    break;
	  else if (isalnum(name[j]))
	    varname[j] = tolower(name[j]);
	  else if (name[j] == '+')
	    varname[j] = 'p';
	  else if (name[j] == '-')
	    varname[j] = 'm';
	  else
	    varname[j] = '_';
	}

      // check for names starting with a number
      if (!isalpha(varname[0]))
	{
	  memmove(varname+1, varname, strlen(varname));
	  varname[0] = 'x';
	}

      // check for duplicate names
      for (int j=0; j<i; j++)
	if (strcmp(varname, xvarname[j])==0)
	  {
	    memmove(varname+1, varname, strlen(varname));
	    varname[0] = 'x';
	    j=0;
	  }
	    
      strcpy(xvarname[i], varname);

      char str[256];

      sprintf(str,"#define %s_%-10s %3d\n", devname, varname, i);
      for (int p=8; str[p]!=0; p++)
	str[p] = toupper(str[p]);
      defines += str;

      switch (var_info.width)
	{
	default:

	  boffset += var_info.width;

	  fprintf(fp, "   char %s[%d]; // %3d %-10s unit %3d, prefix %3d, status %d, flags %d\n",
		 varname,
		 i,
		 var_info.width,
		 name,
		 var_info.unit,
		 var_info.prefix,
		 var_info.status,
		 var_info.flags);

	  sprintf(str, "%-10s = FLOAT", varname);
	  bank_def += str;
	  break;
	case 1:

	  boffset += 1;

	  fprintf(fp, "   uint8_t  %-8s; // %3d %-10s unit %3d, prefix %3d, status %d, flags %d\n",
		 varname,
		 i,
		 name,
		 var_info.unit,
		 var_info.prefix,
		 var_info.status,
		 var_info.flags
		 );

	  sprintf(str, "   \"%-10s = BYTE\",\n", varname);
	  bank_def += str;

	  sprintf(str, "   u8be2local(&bank->%s, data+%d);\n", varname, bcount);
	  bank_copy += str;
	  break;
	case 2:

	  if (boffset%2 != 0)
	    {
	      sprintf(str, "   \"pad%d       = BYTE\",\n", ipad);
	      bank_def += str;

	      sprintf(str, "   bank->pad%d = 0;\n", ipad);
	      bank_copy += str;

	      fprintf(fp, "   uint8_t  pad%d;\n", ipad);

	      ipad++;
	      boffset += 1;
	    }

	  boffset += 2;

	  fprintf(fp, "   uint16_t %-8s; // %3d %-10s unit %3d, prefix %3d, status %d, flags %d\n",
		 varname,
		 i,
		 name,
		 var_info.unit,
		 var_info.prefix,
		 var_info.status,
		 var_info.flags
		 );

	  sprintf(str, "   \"%-10s = WORD\",\n", varname);
	  bank_def += str;

	  sprintf(str, "   u16be2local(&bank->%s, data+%d);\n", varname, bcount);
	  bank_copy += str;
	  break;
	case 4:

	  if (boffset%4 != 0)
	    {
	      for (int p=0; p<boffset%4; p++)
		{
		  sprintf(str, "   \"pad%d       = BYTE\",\n", ipad);
		  bank_def += str;

		  sprintf(str, "   bank->pad%d = 0;\n", ipad);
		  bank_copy += str;

		  fprintf(fp, "   uint8_t  pad%d;\n", ipad);
		  
		  ipad++;
		  boffset += 1;
		}
	    }

	  boffset += 4;

          if (var_info.flags & 1)
            {
              fprintf(fp, "   float    %-8s; // %3d %-10s unit %3d, prefix %3d, status %d, flags %d\n",
                     varname,
                     i,
                     name,
                     var_info.unit,
                     var_info.prefix,
                     var_info.status,
                     var_info.flags
                     );

              sprintf(str, "   \"%-10s = FLOAT\",\n", varname);
            }
          else
            {
              fprintf(fp, "   uint32_t %-8s; // %3d %-10s unit %3d, prefix %3d, status %d, flags %d\n",
                     varname,
                     i,
                     name,
                     var_info.unit,
                     var_info.prefix,
                     var_info.status,
                     var_info.flags
                     );

              sprintf(str, "   \"%-10s = DWORD\",\n", varname);
            }

	  bank_def += str;

	  sprintf(str, "   u32be2local(&bank->%s, data+%d);\n", varname, bcount);
	  bank_copy += str;
	  break;
	}

      bcount += var_info.width;
    }

  fprintf(fp, "};\n");

  if (1)
    {
      char str[256];
      sprintf(str, "#define %s_%-15s %d", devname, "BUFSIZE", bcount);
      for (int p=8; str[p]!=0; p++)
	str[p] = toupper(str[p]);

      fprintf(fp, "\n");
      fprintf(fp, "%s\n", str);
    }

  fprintf(fp, "%s\n", defines.c_str());

  fprintf(fp, "char* %s_InitStr[] = {\n", devname);
  fprintf(fp, "   \"[.]\",\n");
  fputs(bank_def.c_str(), fp);
  fprintf(fp, "   NULL\n};\n");
  fprintf(fp, "\n");

  fprintf(fp, "static void %s_copy(void*xbank, int xbank_size, uint32_t time, const MSCB_INFO* info, const char* data) {\n", devname);
  fprintf(fp, "   %s_bank* bank = (%s_bank*)xbank;\n", devname, devname);
  fprintf(fp, "   bank->_timestamp = time;\n");
  fprintf(fp, "   bank->_protocol_version = info->protocol_version;\n");
  fprintf(fp, "   bank->_n_variables   = info->n_variables;\n");
  fprintf(fp, "   bank->_node_address  = info->node_address;\n");
  fprintf(fp, "   bank->_group_address = info->group_address;\n");
  fprintf(fp, "   bank->_svn_revision  = info->svn_revision;\n");
  fputs(bank_copy.c_str(), fp);
  fprintf(fp, "}\n");
  fprintf(fp, "\n");
  fprintf(fp, "#endif\n");
  fprintf(fp, "/* end */\n");
  fclose(fp);

  fprintf(stderr, "Done.\n");

  return MSCB_SUCCESS;
}

int main(int argc, char* argv[])
{
  if (argc < 2)
    {
      fprintf(stderr,"Usage: %s mscbdev mscbaddr\n", argv[0]);
      exit(1);
    }

  /* Open the Device */
  const char* mscbdev = argv[1];

  /* open device on MSCB */

  fprintf(stderr, "Connecting to MSCB bus \'%s\'\n", mscbdev);

  int mscbfd = mscb_init((char*)mscbdev, NAME_LENGTH, "", FALSE);
  if (mscbfd < 0) {
    fprintf(stderr, "Cannot access MSCB submaster at \"%s\". Check power and connection\n", mscbdev);
    return 1;
  }

  int addr = strtoul(argv[2], NULL, 0);
  
  MakeMscbCode(mscbfd, addr);

  return 0;
}

//end
